package gridmove.controller;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * @author Nat
 *
 * Version: 0.1
 * 
 * Takes input from the keyboard and decides whether or not to pass it on to the Controller.
 *
 */
public class KeyRelay extends KeyAdapter {
	//keeps track of whether a key is currently depressed (if it is, get it some Prozac!)
	private Map<Integer, RepeatingSurvey> keyStates = Collections.synchronizedMap(new HashMap<Integer, RepeatingSurvey>());
	
	private Controller theMan;
	
	public KeyRelay(Controller c) {
		theMan = c;
	}

	@Override
	public void keyPressed(KeyEvent e) {
		//for now, we're looking to eliminate duplicate events - repeated keypresses generated by the OS.
		//we may want to consider implementing our own more intuitive keypress repeater, i.e. when the key is released, finish the current motion and stop. 
		synchronized(keyStates) {
			boolean validKeypress = true;
			if(keyStates.get(e.getKeyCode()) != null)
				if(keyStates.get(e.getKeyCode()).isContinuing())
					validKeypress = false;
			
			if(validKeypress) {
				Direction direction = Direction.NOWHERE;
				switch (e.getKeyCode()) {
				case 37:
					direction = Direction.LEFT;
					break;
				case 38:
					direction = Direction.UP;
					break;
				case 39:
					direction = Direction.RIGHT;
					break;
				case 40:
					direction = Direction.DOWN;
					break;
				default:
					return;
				}

				RepeatingSurvey survey = new RepeatingSurvey(direction, theMan.getAnimator(), theMan.getFrame());
				
				keyStates.put(e.getKeyCode(), survey);
				theMan.move(survey);
			}
		}
	}

	@Override
	public void keyReleased(KeyEvent e) {		
		synchronized(keyStates) {
			if(keyStates.get(e.getKeyCode()) != null) {		
				keyStates.get(e.getKeyCode()).halt();
				keyStates.put(e.getKeyCode(), null);
			}
		}
	}
}
